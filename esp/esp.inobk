#include <esp_task_wdt.h>
#include <HCSR04.h>
#include "connect.h"
#include "server.h"
// #include "INS.h"
#include "motor.h"
#include <I2Cdev.h>
#include <MPU6050_6Axis_MotionApps20.h>
#include <Wire.h>

HCSR04 hcLeft(triggerL, echoL);
HCSR04 hcRight(triggerR, echoR);
// INS ins;
MPU6050 mpu;
_Server server;
TaskHandle_t accGyrTaskHandle, packetSendHandle, motorHandle;
Motor motor();
TickType_t AccGyrTick, motorTick;

uint8_t devStatus;

void AccGyrTask(void *pvParameters)
{
  AccGyrTick = xTaskGetTickCount();
  ins.prevTime = millis();
  uint8_t sendBuffer[48]; //time + acc + gyr + nav + ultrasonic: 4 + 9 * 4 + 2 * 4 = 48

  float leftDist, rightDist;
  uint8_t count;
  while (1)
  {
    //MPU6050
    vTaskDelayUntil(&AccGyrTick, 200 / portTICK_RATE_MS);
    ins.calculate();
    memcpy(sendBuffer, &ins.prevTime, 4);             //copy time
    memcpy(sendBuffer + 4, &ins.accGyrData.acc, 12);  // copy acc
    memcpy(sendBuffer + 16, &ins.accGyrData.gyr, 12); // copy gyr
    memcpy(sendBuffer + 28, &ins.navData, 12);        // copy nav

    Serial.printf("%f, %f, %f\n", ins.navData.roll, ins.navData.pitch, ins.navData.yaw);

    //Motor Control
    leftDist = hcLeft.dist();
    rightDist = hcRight.dist();

    *((float *)sendBuffer + 10) = leftDist;
    *((float *)sendBuffer + 11) = rightDist;

    if (count)
    {
      motor.correctYaw();
      if (!--count)
      {
        // motor.turnRight();
        motor.forward();
      }
    }
    else
    {
      if (leftDist < 10 || rightDist < 10)
      {
        motor.back();
        count = 10;
      }
      else if (leftDist < 30)
        motor.goRight();
      else if (rightDist < 30)
        motor.goLeft();
      else
      {
        motor.forward();
        motor.correctYaw();
      }
    }
    server.sendEnqueue(GET_ATTITUDE, sendBuffer, 48);
  }
}
// void motorTask(void *pvParameters) {
//   Serial.printf("%p %p\n", &leftDist, &rightDist);
//   uint8_t count;
//   motorTick = xTaskGetTickCount();
//   while(1) {
//     server.sendEnqueue(GET_ULTRASONIC, (uint8_t*)&leftDist, 8);
//     // Serial.printf("%f, %f\n", leftDist, rightDist);

// }

void setup()
{
  Serial.begin(115200);
  connectInitial();
  server.initial();
  ins.initial();
  motor.initial();

  Wire.begin();
  Wire.setClock(400000);

  //MPU6050 initialize
  mpu.initialize();
  devStatus = mpu.dmpInitialize();
  mpu.setXGyroOffset(220);
  mpu.setYGyroOffset(76);
  mpu.setZGyroOffset(-85);
  mpu.setZAccelOffset(1788);

  if (!devStatus)
  {
    mpu.CalibrateAccel(6);
    mpu.CalibrateGyro(6);
    mpu.PrintActiveOffsets();

    // mpu.dmpSetFIFORate(19);

    mpu.setDMPEnabled(true);

    // attachInterrupt(digitalPinToInterrupt(35), dmpDataReady, RISING);
  }
  else
  {
    // ERROR!
    // 1 = initial memory load failed
    // 2 = DMP configuration updates failed
    // (if it's going to break, usually the code will be 1)
    Serial.print(F("DMP Initialization failed (code "));
    Serial.print(devStatus);
    Serial.println(F(")"));
  }
  // xTaskCreate(
  //   sendPacketTask,
  //   "Task2",
  //   10000,
  //   NULL,
  //   10,
  //   &packetSendHandle);
  // motor.stop();
}
// int buffer[ValCnt];
uint32_t now = 0;
String output = "";

STATE state = STOP;
uint8_t recvCMD;
void loop()
{
  recvCMD = server.readCMD();
  switch (state)
  {
  case NORMAL:
    if (receiveData(PERSON_DETECT) && false)
    {
      Serial.println("person finded");
      motor.stop();
      vTaskDelete(accGyrTaskHandle);
      server.sendCMD(PERSON_FINDED);
      state = STOP;
    }
    else
    {
      // Serial.println("No person");
    }
    vTaskDelay(1);
    break;

  case STOP:
    if (recvCMD)
    {
      Serial.printf("0x%02x\n", recvCMD);
      switch (recvCMD)
      {
      case (uint8_t)GET_IMG:
      {
        // vTaskSuspend(accGyrTaskHandle);
        startConnect();
        sendCommand(GET_IMG);
        if (startReceive())
        {
          endConnect();
          state = NORMAL;
          // Serial.println("Timeout!");
          break;
        }
        uint8_t img_buffer[1920];
        uint16_t i = 160;
        while (i--)
        {
          receiveBytes(img_buffer, 1920);
          server.sendEnqueue(GET_IMG, img_buffer, 1920);
          server.flushQueue();
        }
        endConnect();
        AccGyrTick = xTaskGetTickCount();
        // vTaskResume(accGyrTaskHandle);
        break;
      }
      case (uint8_t)CONTINUE_FIND:
        xTaskCreatePinnedToCore(
            AccGyrTask,
            "Task1",
            10000,
            NULL,
            configMAX_PRIORITIES,
            &accGyrTaskHandle,
            0);
        state = NORMAL;
        break;
      }
    }
    break;

  default:
    break;
  }

  server.flushQueue();

  // leftDist = hcLeft.dist();
  // rightDist = hcRight.dist();
  // Serial.printf("%f %f\n", leftDist, rightDist);
  // hcDist = ((uint8_t)(leftDist < 30) << 1) + (uint8_t)(rightDist < 30);

  // switch (hcDist)
  // {
  //   case 0:
  //     if(prev_hcDist) motor.target_yaw = ins.yaw;
  //     motor.fix_yaw();
  //     // Serial.println("forward");
  //     break;
  //   case 1:
  //     if(prev_hcDist != 1) motor.target_z = 10;
  //     motor.fix_z();
  //     // Serial.println("left");
  //     break;
  //   case 2:
  //     if(prev_hcDist != 2) motor.target_z = -10;
  //     motor.fix_z();
  //     // Serial.println("right");
  //     break;
  //   case 3:
  //     motor.target_yaw = ins.yaw + 90;
  //     if(motor.target_yaw > 180) motor.target_yaw -= 360;
  //     motor.turnLeft();
  //     // Serial.println("back");
  //     while(abs(ins.yaw - motor.target_yaw) > 1) {
  //       vTaskDelay(1);
  //       Serial.printf("%f %f %f\n", motor.target_yaw, ins.yaw, abs(ins.yaw - motor.target_yaw));
  //     }
  //     motor.forward();
  //     break;
  // }
  // Serial.printf("%f %f\n", ins.yaw, ins.toTarget(motor.target_yaw));
  // delay(500);
  // prev_hcDist = hcDist;

  // Serial.println(motor.fix_speed);

  // if(millis() - now > DETECT_INTERVAL) {
  //   motor.fix_yaw();
  //   now = millis();
  //   // Serial.println(motor.fix_speed);
  // }
  // output = String(motor.left_speed) + " " + String(motor.right_speed);
  // Serial.println(to_string(motor.left_speed) + " " + to_string(motor.right_speed));
  // server.sendData(DEBUG, &(motor.fix_speed), 1);
  // int16_t buffer[ValCnt];
  // float* realVals = (float*)malloc(sizeof(float) * ValCnt);
  // ins.readAccGyr(buffer);
  // ins.rectify(buffer, realVals);

  // float fNorm = sqrt(ins.realVals[0] * ins.realVals[0] + ins.realVals[1] * ins.realVals[1] + ins.realVals[2] * ins.realVals[2]);
  // float fRoll = ins.GetRoll(fNorm); //计算Roll角
  // if (ins.realVals[1] > 0) {
  //   fRoll = -fRoll;
  // }
  // float fPitch = ins.GetPitch(fNorm); //计算Pitch角
  // if (ins.realVals[0] < 0) {
  //   fPitch = -fPitch;
  // }

  // printf("%f , %f\n", fRoll, fPitch);

  // for (int i = 0; i < ValCnt; i++)
  // {
  //   Serial.printf("%f  ", realVals[i]);
  // }
  // Serial.println();

  //  if(ins.readMPU(0x6B))ins.writeMPU(0x6B, 0);
  // buffer = ins.readMPU(0x68, 2);
  // Serial.printf("0x%02x%02x\n", buffer[0], buffer[1]);
  // free(buffer);
  // Serial.printf("0x%02x\n", ins.readMPU(0x6B));
  // Serial.printf("0x%02x\n", ins.readMPU(0x75));

  // // sendData(PERSON_DETECTION, result);
  // delayMicroseconds(50);
}
